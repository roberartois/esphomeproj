esphome:
  name: esp32c3sm-testboard
  friendly_name: ESP32C3sm_TestBoard
  name_add_mac_suffix: False
  project: 
    version: 0.3.1
    name: "IevgenGubareni.WaterHeater-ESPC3-supermini"
  on_boot:
    priority: -100
    then:
      - lambda: |-
          id(wanted_temp_number).publish_state(id(wanted_temperature));
          id(one_heater_temp_number).publish_state(id(one_heater_temperature));

# GPIO SCHEME (ESP32C3 Super Mini)
#======================================
# 5V
# GND
# 3V3
# GPIO04 - BUTTON_NEXT  
# GPIO03 - BUTTON_UP
# GPIO02 // - BUTTON_NEXT   // pin is high at BOOT, boot failure if pulled LOW 
# GPIO01
# GPIO00 // - BUTTON_UP     // boot failure if pulled LOW
#======================================        
# GPIO21        // UART TX   // pin is high at BOOT, boot failure if pulled LOW        
# GPIO20        // UART RX   // pin is high at BOOT        
# GPIO10        
# GPIO09 - SCL       
# GPIO08 - SDA       
# GPIO07 - ONE WIRE                
# GPIO06 - RELAY 1, 2 
# GPIO05 - RELAY 3, 4

esp32:
  board: esp32-c3-devkitm-1
  variant: ESP32C3
  framework:
    type: esp-idf

logger:

mqtt:
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  username: !secret mqtt_user
  password: !secret mqtt_pwd

  discovery: true
  discovery_prefix: homeassistant
  discovery_retain: true
  discovery_unique_id_generator: mac
  discovery_object_id_generator: device_name

  birth_message:
    topic: myavailability/topic
    payload: online
  will_message:
    topic: myavailability/topic
    payload: offline

ota:
  - plartform: esphome
    password: !secret ota_password
  - platform: web_server

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Esp32C3Sm-Testboard"
    password: "9InqkGlD8sLz"

captive_portal:

globals:
  - id: wanted_temperature
    type: int
    restore_value: False
    initial_value: "55"
  - id: one_heater_temperature
    type: int
    restore_value: False
    initial_value: "45"
  - id: position
    type: int
    restore_value: false
    initial_value: '0'
  - id: last_activity
    type: unsigned long
    restore_value: false
    initial_value: '0'
  - id: dimmed
    type: bool
    restore_value: false
    initial_value: 'false'

text_sensor:
  - platform: template
    name: "Free Heap"
    id: free_heap
    lambda: |-
      return to_string(esp_get_free_heap_size()) + " bytes";
    update_interval: 60s
    icon: mdi:memory

i2c:
  scl: GPIO09
  sda: GPIO08
  id: i2c_bus

display:
  - platform: ssd1306_i2c
    model: SSD1306_128X32
    invert: False
    id: oled_display
    rotation: 0
    brightness: 1.0
    pages:
      - id: page_1
        lambda: |-
          std::string status = "";
          if (id(heating_switch).state) {
            status += "*";
            if (id(relay_1_2).state && id(relay_3_4).state) {
              status += "••";
            } else if (id(relay_1_2).state || id(relay_3_4).state) {
              status += "•";
            }
          }
          it.printf(0, 0, id(big_font), "T:%.1f %s", id(current_temp).state, status.c_str());
      - id: page_2
        lambda: |-
          it.printf(0, 0, id(big_font), "W:%d", id(wanted_temperature));
      - id: page_3
        lambda: |-
          it.printf(0, 0, id(big_font), "1H:%d", id(one_heater_temperature));
      - id: page_info
        lambda: |-
          it.printf(0, 0, id(big_font), "Heat: %s", id(heating_switch).state ? "ON" : "OFF");
      - id: page_clear
        lambda: |-
          // Empty page

font:
  - id: big_font
    size: 20
    file: "https://github.com/IdreesInc/Monocraft/releases/download/v3.0/Monocraft.ttf"

one_wire:
  - platform: gpio
    pin: GPIO07
    id: water_temperature

sensor:
  - platform: dallas_temp
    name: "Water Heater Temperature"
    id: current_temp
    update_interval: 120s
    one_wire_id: water_temperature
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    icon: mdi:thermometer

button:
  - platform: restart
    id: restart_button
    name: "Restart board"
    icon: mdi:restart

switch:
  - platform: gpio
    pin: GPIO05
    id: relay_3_4
    name: "Relay 3 & 4"
    restore_mode: ALWAYS_OFF
    inverted: true
    icon: mdi:toggle-switch

  - platform: gpio
    pin: GPIO06
    id: relay_1_2
    name: "Relay 1 & 2"
    restore_mode: ALWAYS_OFF
    inverted: true
    icon: mdi:toggle-switch

  - platform: template
    name: "Heating On/Off"
    id: heating_switch
    restore_mode: ALWAYS_OFF
    optimistic: true
    turn_on_action:
      - script.execute: show_info_page_script
    turn_off_action:
      - script.execute: show_info_page_script

binary_sensor:
  - platform: gpio
    pin: 
      number: GPIO04
      inverted: true
      mode: INPUT_PULLUP
    name: "Button NEXT"
    id: button_next
    filters:
      - delayed_on: 20ms
      - delayed_off: 50ms
    on_release:
      then:
        - lambda: |-
            if (id(dimmed)) {
              id(oled_display).show_page(id(page_1));
              id(dimmed) = false;
              return;
            }
            id(last_activity) = millis();
            id(position) += 1;
            if (id(position) > 2) {
              id(position) = 0;
            }
            switch (id(position)) {
              case 0: id(oled_display).show_page(id(page_1)); break;
              case 1: id(oled_display).show_page(id(page_2)); break;
              default: id(oled_display).show_page(id(page_3)); break;
            }

  - platform: gpio
    pin: 
      number: GPIO03
      inverted: true
      mode: INPUT_PULLUP
    name: "Button UP"
    id: button_up
    filters:
      - delayed_on: 20ms
      - delayed_off: 50ms
    on_release:
      then:
        - lambda: |-
            if (id(dimmed)) {
              id(oled_display).show_page(id(page_1));
              id(dimmed) = false;
              return;
            }
            id(last_activity) = millis();
            if (id(position) == 0) {
              id(heating_switch).toggle();
            } else if (id(position) == 1) {
              id(wanted_temperature) += 5;
              if (id(wanted_temperature) > 85) {
                id(wanted_temperature) = 25;
              }
              id(wanted_temp_number).publish_state(id(wanted_temperature));
            } else if (id(position) == 2) {
              id(one_heater_temperature) += 5;
              if (id(one_heater_temperature) > 85) {
                id(one_heater_temperature) = 25;
              }
              id(one_heater_temp_number).publish_state(id(one_heater_temperature));
            }

number:
  - platform: template
    name: "Wanted Temperature"
    id: wanted_temp_number
    min_value: 25
    max_value: 85
    step: 5
    unit_of_measurement: "°C"
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(wanted_temperature) = (int)x;
            id(last_activity) = millis();
            id(dimmed) = false;
            id(oled_display).show_page(id(page_2));

  - platform: template
    name: "One Heater Temperature"
    id: one_heater_temp_number
    min_value: 25
    max_value: 85
    step: 5
    unit_of_measurement: "°C"
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(one_heater_temperature) = (int)x;
            id(last_activity) = millis();
            id(dimmed) = false;
            id(oled_display).show_page(id(page_3));

script:
  - id: heater_control_script
    mode: restart
    then:
      - lambda: |-
          // Якщо heating_switch вимкнено — вимкнути обидва реле і завершити
          if (!id(heating_switch).state) {
            id(relay_3_4).turn_off();
            id(relay_1_2).turn_off();
            return;
          }
          float temp = id(current_temp).state;
          int wanted = id(wanted_temperature);
          int one_heater = id(one_heater_temperature);

          if (temp > wanted) {
            id(relay_3_4).turn_off();
            id(relay_1_2).turn_off();
          } else if (temp > one_heater && temp <= wanted) {
            id(relay_1_2).turn_off();
            id(relay_3_4).turn_on();
          } else if (temp <= one_heater) {
            id(relay_3_4).turn_on();
            id(relay_1_2).turn_on();
          }

  - id: show_info_page_script
    mode: restart
    then:
      - lambda: |-
          id(oled_display).show_page(id(page_info));
      - delay: 10s
      - lambda: |-
          id(oled_display).show_page(id(page_1));

interval:
  - interval: 3600s
    then:
      - lambda: |-
          id(wanted_temp_number).publish_state(id(wanted_temperature));
          id(one_heater_temp_number).publish_state(id(one_heater_temperature));
  - interval: 30s
    then:
      - lambda: |-
          // Через 60 секунд після активності вимкнути дисплей (page_clear)
          if (!id(dimmed) && (millis() - id(last_activity)) > 60000) {
            id(oled_display).show_page(id(page_clear));
            id(dimmed) = true;
          } else if (!id(dimmed) && (millis() - id(last_activity)) > 30000) {
            // Через 30 секунд після активності показати page_1
            id(oled_display).show_page(id(page_1));
          }
  - interval: 10s
    then:
      - script.execute: heater_control_script
